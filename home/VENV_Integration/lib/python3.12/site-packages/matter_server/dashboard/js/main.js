class e{constructor(e){this.data=e,this.node_id=e.node_id,this.date_commissioned=e.date_commissioned,this.last_interview=e.last_interview,this.interview_version=e.interview_version,this.available=e.available,this.is_bridge=e.is_bridge,this.attributes=e.attributes,this.attribute_subscriptions=e.attribute_subscriptions}get nodeLabel(){const e=this.attributes["0/40/5"];return e?e.includes("\0\0")?"":e.trim():""}get vendorName(){return this.attributes["0/40/1"]}get productName(){return this.attributes["0/40/3"]}get serialNumber(){return this.attributes["0/40/15"]}get updateState(){return this.attributes["0/42/2"]}get updateStateProgress(){return this.attributes["0/42/3"]}update(t){return new e({...this.data,...t})}}class t{constructor(e){this.ws_server_url=e,this.serverInfo=void 0,this.ws_server_url=e}get connected(){var e;return(null===(e=this.socket)||void 0===e?void 0:e.readyState)===WebSocket.OPEN}async connect(e,t){if(this.socket)throw new Error("Already connected");return console.debug("Trying to connect"),new Promise(((s,n)=>{this.socket=new WebSocket(this.ws_server_url),this.socket.onopen=()=>{console.log("WebSocket Connected")},this.socket.onclose=e=>{console.log(`WebSocket Closed: Code=${e.code}, Reason=${e.reason}`),t()},this.socket.onerror=e=>{console.error("WebSocket Error: ",e),console.dir(e),n(new Error("WebSocket Error"))},this.socket.onmessage=t=>{const n=JSON.parse(t.data);if(console.log("WebSocket OnMessage",n),!this.serverInfo)return this.serverInfo=n,void s(void 0);e(n)}}))}disconnect(){this.socket&&(this.socket.close(),this.socket=void 0)}sendMessage(e){if(!this.socket)throw new Error("Not connected");console.log("WebSocket send message",e),this.socket.send(JSON.stringify(e))}}class s extends Error{}class n extends s{}class i{constructor(e,s){this.url=e,this.isProduction=s,this.connection=new t(this.url),this.nodes={},this.serverBaseAddress=this.url.split("://")[1].split(":")[0]||"",this._result_futures={},this.msgId=0,this.eventListeners={},this.url=e,this.isProduction=s}get serverInfo(){return this.connection.serverInfo}addEventListener(e,t){return this.eventListeners[e]||(this.eventListeners[e]=[]),this.eventListeners[e].push(t),()=>{this.eventListeners[e]=this.eventListeners[e].filter((e=>e!==t))}}async commissionWithCode(e,t){return await this.sendCommand("commission_with_code",0,{code:e,network_only:t})}async setWifiCredentials(e,t){await this.sendCommand("set_wifi_credentials",0,{ssid:e,credentials:t})}async setThreadOperationalDataset(e){await this.sendCommand("set_thread_dataset",0,{dataset:e})}async openCommissioningWindow(e,t,s,n,i){return await this.sendCommand("open_commissioning_window",0,{node_id:e,timeout:t,iteration:s,option:n,distriminator:i})}async discoverCommissionableNodes(){return await this.sendCommand("discover_commissionable_nodes",0,{})}async getMatterFabrics(e){return await this.sendCommand("get_matter_fabrics",3,{})}async removeMatterFabric(e,t){await this.sendCommand("remove_matter_fabric",3,{node_id:e,fabric_index:t})}async pingNode(e){return await this.sendCommand("ping_node",0,{node_id:e})}async getNodeIPAddresses(e,t,s){return await this.sendCommand("get_node_ip_addresses",8,{node_id:e,prefer_cache:t,scoped:s})}async removeNode(e){await this.sendCommand("remove_node",0,{node_id:e})}async interviewNode(e){await this.sendCommand("interview_node",0,{node_id:e})}async importTestNode(e){await this.sendCommand("import_test_node",0,{dump:e})}async readAttribute(e,t){return await this.sendCommand("read_attribute",0,{node_id:e,attribute_path:t})}async writeAttribute(e,t,s){await this.sendCommand("write_attribute",0,{node_id:e,attribute_path:t,value:s})}async checkNodeUpdate(e){return await this.sendCommand("check_node_update",10,{node_id:e})}async updateNode(e,t){await this.sendCommand("update_node",10,{node_id:e,software_version:t})}async sendCommand(e,t=void 0,s){if(t&&this.serverInfo.schema_version<t)throw new n(`Command not available due to incompatible server version. Update the Matter Server to a version that supports at least api schema ${t}.`);const i=++this.msgId,o={message_id:i.toString(),command:e,args:s},r=new Promise(((e,t)=>{this._result_futures[i]={resolve:e,reject:t},this.connection.sendMessage(o)}));return r.finally((()=>{delete this._result_futures[i]})),r}async connect(){this.connection.connected||await this.connection.connect((e=>this._handleIncomingMessage(e)),(()=>this.fireEvent("connection_lost")))}disconnect(e=!0){this.connection&&this.connection.connected&&this.connection.disconnect(),e&&(localStorage.removeItem("matterURL"),location.reload())}async startListening(){await this.connect();const t=await this.sendCommand("start_listening",0,{}),s={};for(const n of t)s[n.node_id]=new e(n);this.nodes=s}_handleIncomingMessage(e){if("event"in e)this._handleEventMessage(e);else if("error_code"in e){const t=e,s=this._result_futures[t.message_id];s&&(s.reject(new Error(t.details)),delete this._result_futures[t.message_id])}else if("result"in e){const t=e,s=this._result_futures[t.message_id];s&&(s.resolve(t.result),delete this._result_futures[t.message_id])}else console.warn("Received message with unknown format",e)}_handleEventMessage(t){if(console.log("Incoming event",t),"node_added"===t.event){const s=new e(t.data);return this.nodes={...this.nodes,[s.node_id]:s},void this.fireEvent("nodes_changed")}if("node_removed"===t.event)return delete this.nodes[t.data],this.nodes={...this.nodes},void this.fireEvent("nodes_changed");if("node_updated"===t.event){const s=new e(t.data);return this.nodes={...this.nodes,[s.node_id]:s},void this.fireEvent("nodes_changed")}if("attribute_updated"===t.event){const[s,n,i]=t.data,o=new e(this.nodes[s]);return o.attributes[n]=i,this.nodes={...this.nodes,[o.node_id]:o},void this.fireEvent("nodes_changed")}return"server_info_updated"===t.event?(this.connection.serverInfo=t.data,void this.fireEvent("server_info_updated")):void 0}fireEvent(e,t){const s=this.eventListeners[e];if(s)for(const e of s)e()}}!async function(){import("./matter-dashboard-app-Bs2zeWCY.js").then((function(e){return e.q}));let e="";const t=location.href.includes(":5580")||location.href.includes("hassio_ingress");if(t){let t=window.location.origin+window.location.pathname;t.endsWith("/")&&(t=t.slice(0,-1)),e=t.replace("http","ws")+"/ws",console.log(`Connecting to Matter Server API using url: ${e}`)}else{let t=localStorage.getItem("matterURL");if(!t){if(t=prompt("Enter Websocket URL to a running Matter Server","ws://localhost:5580/ws"),!t)return void alert("Unable to connect without URL");localStorage.setItem("matterURL",t)}e=t}const s=new i(e,t),n=document.createElement("matter-dashboard-app");n.client=s,document.body.append(n)}();
